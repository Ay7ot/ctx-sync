import * as fs from 'node:fs';
import * as path from 'node:path';

declare global {
  var TEST_DIR: string;
}

import {
  generateKey,
  decrypt,
  encryptState,
  decryptState,
} from '../../src/core/encryption.js';
import { writeState, readState, type StateData } from '../../src/core/state-manager.js';
import { parseEnvFile } from '../../src/core/env-handler.js';
import {
  sanitizeError,
  wrapConsole,
  unwrapConsole,
} from '../../src/core/log-sanitizer.js';

/**
 * Security: Penetration Test Suite
 *
 * Comprehensive automated penetration tests covering all attack vectors
 * from the threat model in testing.md. Includes:
 *
 * 1. Secret exposure via logs (DEBUG mode)
 * 2. Stack trace sanitization
 * 3. Git history analysis (state file content verification)
 * 4. Tampered state file detection
 * 5. Replaced state file detection (attacker's key)
 * 6. Fuzzing: malformed .env files
 * 7. Fuzzing: malformed Age ciphertext
 */
describe('Security: Penetration Tests', () => {
  let publicKey: string;
  let privateKey: string;

  beforeAll(async () => {
    const keys = await generateKey();
    publicKey = keys.publicKey;
    privateKey = keys.privateKey;
  });

  afterEach(() => {
    unwrapConsole();
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Secret Exposure via Logs
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('Secret Exposure via Logs', () => {
    it('should not expose secrets with DEBUG=* when sanitizer is active', () => {
      const captured: string[] = [];
      const originalLog = console.log;
      const originalDebug = console.debug;
      const originalError = console.error;

      console.log = (...args: unknown[]) => captured.push(args.map(String).join(' '));
      console.debug = (...args: unknown[]) => captured.push(args.map(String).join(' '));
      console.error = (...args: unknown[]) => captured.push(args.map(String).join(' '));

      wrapConsole();

      // Simulate various secret types being logged
      console.log('Processing sk_live_4eC39HqLyjWDarjtT1zdp7dc');
      console.debug('Auth: ghp_ABCDEFghijklmnopqrstuvwxyz1234567890');
      console.error('Failed AGE-SECRET-KEY-1QQQQQQQQQQQQQQQQQQQTESTKEY');
      console.debug('AWS AKIAIOSFODNN7EXAMPLE in config');
      console.log('Token xoxb-123456789-123456789-abcdefghij');
      console.debug('OpenAI sk-abcdefghijklmnopqrstuvwxyz');
      console.log('DB: postgres://admin:s3cretpass@db.example.com/app');

      unwrapConsole();
      console.log = originalLog;
      console.debug = originalDebug;
      console.error = originalError;

      const allOutput = captured.join('\n');

      // Verify NO raw secret appears in output
      expect(allOutput).not.toContain('4eC39HqLyjWDarjtT1zdp7dc');
      expect(allOutput).not.toContain('ABCDEFghijklmnopqrstuvwxyz1234567890');
      expect(allOutput).not.toContain('1QQQQQQQQQQQQQQQQQQQTESTKEY');
      expect(allOutput).not.toContain('IOSFODNN7EXAMPLE');
      expect(allOutput).not.toContain('123456789-123456789-abcdefghij');
      expect(allOutput).not.toContain('abcdefghijklmnopqrstuvwxyz');
      expect(allOutput).not.toContain('s3cretpass');

      // Verify redaction markers are present
      expect(allOutput).toContain('***REDACTED***');
    });

    it('should sanitize secrets from all console methods simultaneously', () => {
      const secret = 'sk_live_multimethodtest123';
      const methods = ['log', 'error', 'warn', 'debug'] as const;
      const captured: Record<string, string[]> = {};

      // Save originals
      const originals: Record<string, (...args: unknown[]) => void> = {};
      for (const method of methods) {
        originals[method] = console[method];
        captured[method] = [];
        console[method] = (...args: unknown[]) => {
          captured[method]!.push(args.map(String).join(' '));
        };
      }

      wrapConsole();

      for (const method of methods) {
        console[method](`Test ${method}: ${secret}`);
      }

      unwrapConsole();

      // Restore originals
      for (const method of methods) {
        console[method] = originals[method]!;
      }

      // Verify none contain the raw secret
      for (const method of methods) {
        expect(captured[method]!.join('')).not.toContain('multimethodtest123');
      }
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2. Stack Trace Sanitization
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('Stack Trace Sanitization', () => {
    it('should sanitize Stripe keys from stack traces', () => {
      const err = new Error('Payment failed for sk_live_secret123');
      const sanitized = sanitizeError(err);
      expect(sanitized.stack ?? '').not.toContain('sk_live_secret123');
    });

    it('should sanitize Age keys from stack traces', () => {
      const err = new Error('Key error AGE-SECRET-KEY-1STACKTRACETEST');
      const sanitized = sanitizeError(err);
      expect(sanitized.stack ?? '').not.toContain('AGE-SECRET-KEY-1STACKTRACETEST');
    });

    it('should sanitize database URLs from stack traces', () => {
      const err = new Error('Connection: mongodb://admin:secret@cluster/db');
      const sanitized = sanitizeError(err);
      expect(sanitized.stack ?? '').not.toContain('admin:secret');
    });

    it('should sanitize PEM keys from stack traces', () => {
      const err = new Error(
        'Parse error: -----BEGIN PRIVATE KEY-----\nABC123\n-----END PRIVATE KEY-----',
      );
      const sanitized = sanitizeError(err);
      expect(sanitized.stack ?? '').not.toContain('ABC123');
    });

    it('should sanitize multiple secret types in one stack', () => {
      const err = new Error(
        'Errors: sk_live_abc ghp_def AKIAIOSFODNN7EXAMPLE',
      );
      const sanitized = sanitizeError(err);
      const stack = sanitized.stack ?? '';
      expect(stack).not.toContain('sk_live_abc');
      expect(stack).not.toContain('ghp_def');
      expect(stack).not.toContain('AKIAIOSFODNN7EXAMPLE');
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3. Encrypted State File Content Verification
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('State File Content (Git History)', () => {
    it('should have no plaintext secrets in encrypted state files', async () => {
      const stateDir = path.join(globalThis.TEST_DIR, 'pentest-git-history');
      fs.mkdirSync(stateDir, { recursive: true });

      const envVars = {
        'test-project': {
          AWS_KEY: { value: 'AKIAIOSFODNN7EXAMPLE', addedAt: '2025-01-01T00:00:00Z' },
          GITHUB_TOKEN: { value: 'ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', addedAt: '2025-01-01T00:00:00Z' },
          SLACK_TOKEN: { value: 'xoxb-123456789-123456789-abc', addedAt: '2025-01-01T00:00:00Z' },
          STRIPE_KEY: { value: 'sk_live_4eC39HqLyjWDarjtT1zdp7dc', addedAt: '2025-01-01T00:00:00Z' },
          DB_URL: { value: 'postgres://user:pass@localhost/db', addedAt: '2025-01-01T00:00:00Z' },
        },
      };

      await writeState(stateDir, envVars, publicKey, 'env-vars');

      const onDisk = fs.readFileSync(path.join(stateDir, 'env-vars.age'), 'utf-8');

      // None of these should ever appear in the file
      expect(onDisk).not.toContain('AKIAIOSFODNN7EXAMPLE');
      expect(onDisk).not.toContain('ghp_');
      expect(onDisk).not.toContain('xoxb-');
      expect(onDisk).not.toContain('sk_live_');
      expect(onDisk).not.toContain('user:pass');
      expect(onDisk).not.toContain('test-project');

      // Should not contain any JSON structure
      expect(onDisk).not.toMatch(/"value"\s*:/);
      expect(onDisk).not.toMatch(/"password"\s*:/i);

      // Must be valid Age ciphertext
      expect(onDisk).toContain('-----BEGIN AGE ENCRYPTED FILE-----');
    });

    it('should have no plaintext in any of the 6 state file types', async () => {
      const stateDir = path.join(globalThis.TEST_DIR, 'pentest-all-state');
      fs.mkdirSync(stateDir, { recursive: true });

      const stateData: Record<string, { data: unknown; fileType: 'state' | 'env-vars' | 'docker-state' | 'mental-context' | 'services' | 'directories'; sensitiveParts: string[] }> = {
        state: {
          data: {
            machine: { id: 'macbook', hostname: 'dev.local' },
            projects: [{ name: 'secret-project', path: '~/projects/secret' }],
          },
          fileType: 'state',
          sensitiveParts: ['macbook', 'dev.local', 'secret-project'],
        },
        envVars: {
          data: { 'my-app': { SECRET: { value: 'top-secret-value', addedAt: '2025-01-01' } } },
          fileType: 'env-vars',
          sensitiveParts: ['top-secret-value', 'my-app'],
        },
        docker: {
          data: { 'my-app': { services: [{ name: 'postgres', image: 'postgres:15', port: 5432 }] } },
          fileType: 'docker-state',
          sensitiveParts: ['my-app'],
        },
        mental: {
          data: { 'my-app': { currentTask: 'Fixing auth bug', blockers: ['Waiting on API keys'] } },
          fileType: 'mental-context',
          sensitiveParts: ['Fixing auth bug', 'Waiting on API keys'],
        },
        services: {
          data: { services: [{ name: 'dev', command: 'npm run dev', port: 3000 }] },
          fileType: 'services',
          sensitiveParts: ['npm run dev'],
        },
        directories: {
          data: { recentDirs: [{ path: '~/secret/path', frequency: 5 }], pinnedDirs: [] },
          fileType: 'directories',
          sensitiveParts: ['~/secret/path'],
        },
      };

      for (const [, config] of Object.entries(stateData)) {
        await writeState(stateDir, config.data as StateData, publicKey, config.fileType);
      }

      // Verify each file type
      for (const [, config] of Object.entries(stateData)) {
        const filename = config.fileType === 'env-vars' ? 'env-vars.age'
          : config.fileType === 'docker-state' ? 'docker-state.age'
          : config.fileType === 'mental-context' ? 'mental-context.age'
          : `${config.fileType}.age`;

        const filePath = path.join(stateDir, filename);
        if (!fs.existsSync(filePath)) continue;

        const onDisk = fs.readFileSync(filePath, 'utf-8');
        expect(onDisk).toContain('-----BEGIN AGE ENCRYPTED FILE-----');

        for (const sensitive of config.sensitiveParts) {
          expect(onDisk).not.toContain(sensitive);
        }
      }
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 4. Tampered State File Detection
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('Tampered State Files', () => {
    it('should detect corrupted encrypted files (appended data)', async () => {
      const data = { secret: 'my-value' };
      const ciphertext = await encryptState(data, publicKey);

      // Tamper by appending
      const tampered = ciphertext + 'TAMPERED';

      await expect(decryptState(tampered, privateKey)).rejects.toThrow();
    });

    it('should detect corrupted encrypted files (modified bytes)', async () => {
      const data = { key: 'value' };
      const ciphertext = await encryptState(data, publicKey);

      // Tamper in the middle of the ciphertext
      const lines = ciphertext.split('\n');
      if (lines.length > 2) {
        const bodyLine = lines[1]!;
        if (bodyLine.length > 5) {
          lines[1] = bodyLine.slice(0, 3) + 'XX' + bodyLine.slice(5);
        }
      }
      const tampered = lines.join('\n');

      await expect(decryptState(tampered, privateKey)).rejects.toThrow();
    });

    it('should detect truncated encrypted files', async () => {
      const data = { secret: 'test' };
      const ciphertext = await encryptState(data, publicKey);

      // Truncate
      const truncated = ciphertext.slice(0, ciphertext.length / 2);

      await expect(decryptState(truncated, privateKey)).rejects.toThrow();
    });

    it('should detect tampered state on disk via writeState/readState', async () => {
      const stateDir = path.join(globalThis.TEST_DIR, 'pentest-tamper');
      fs.mkdirSync(stateDir, { recursive: true });

      // Write legitimate state
      const envData = { 'app': { KEY: { value: 'secret', addedAt: '2025-01-01' } } };
      await writeState(stateDir, envData, publicKey, 'env-vars');

      // Tamper with the file
      const agePath = path.join(stateDir, 'env-vars.age');
      const content = fs.readFileSync(agePath, 'utf-8');
      fs.writeFileSync(agePath, content + 'TAMPERED', 'utf-8');

      // Reading should fail
      await expect(readState(stateDir, privateKey, 'env-vars')).rejects.toThrow();
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5. Replaced State File (Attacker's Key)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('Replaced State Files (Attacker Key)', () => {
    it('should fail decryption when file is replaced with one encrypted by a different key', async () => {
      // Attacker generates their own key
      const attackerKeys = await generateKey();

      // Attacker encrypts malicious data with their key
      const maliciousData = { 'app': { EVIL: { value: 'malicious-payload', addedAt: '2025-01-01' } } };
      const maliciousCiphertext = await encryptState(maliciousData, attackerKeys.publicKey);

      // Try to decrypt with the legitimate user's key
      await expect(decryptState(maliciousCiphertext, privateKey)).rejects.toThrow();
    });

    it('should fail when attacker replaces state file on disk', async () => {
      const stateDir = path.join(globalThis.TEST_DIR, 'pentest-replace');
      fs.mkdirSync(stateDir, { recursive: true });

      // Write legitimate state
      const legitimate = { 'app': { KEY: { value: 'real-secret', addedAt: '2025-01-01' } } };
      await writeState(stateDir, legitimate, publicKey, 'env-vars');

      // Attacker replaces the file
      const attackerKeys = await generateKey();
      const malicious = await encryptState(
        { 'app': { KEY: { value: 'evil-value', addedAt: '2025-01-01' } } },
        attackerKeys.publicKey,
      );
      fs.writeFileSync(path.join(stateDir, 'env-vars.age'), malicious, 'utf-8');

      // Reading should fail because the user's key can't decrypt attacker's ciphertext
      await expect(readState(stateDir, privateKey, 'env-vars')).rejects.toThrow();
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 6. Fuzzing: Malformed .env Files
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('Fuzzing: Malformed .env files', () => {
    const malformedInputs: Array<{ name: string; input: string }> = [
      { name: 'empty file', input: '' },
      { name: 'no key (=value)', input: '=value' },
      { name: 'no value (KEY=)', input: 'KEY=' },
      { name: 'no equals', input: 'KEYONLY' },
      { name: 'null byte', input: 'KEY=val\x00ue' },
      { name: 'very long value', input: 'KEY=' + 'A'.repeat(1_000_000) },
      { name: 'duplicate keys', input: 'KEY=val1\nKEY=val2' },
      { name: 'binary data', input: '\x00\x01\x02\x03' },
      { name: 'Windows line endings', input: 'KEY1=val1\r\nKEY2=val2' },
      { name: 'export syntax', input: 'export KEY=value' },
      { name: 'comments only', input: '# comment\n# another comment' },
      { name: 'whitespace only', input: '   \n   \n   ' },
      { name: 'mixed valid and invalid', input: 'VALID=ok\n=broken\nALSO_VALID=yes' },
      { name: 'very long key', input: 'K'.repeat(10_000) + '=value' },
      { name: 'unicode key', input: 'ðŸ”‘=value' },
      { name: 'newlines in value (quoted)', input: 'KEY="line1\\nline2"' },
      { name: 'tab characters', input: 'KEY\t=\tvalue' },
      { name: 'multiple equals', input: 'KEY=val=ue=extra' },
      { name: 'trailing whitespace', input: 'KEY=value   \n' },
      { name: 'leading whitespace', input: '   KEY=value\n' },
    ];

    for (const { name, input } of malformedInputs) {
      it(`should handle safely: ${name}`, () => {
        // Should not throw
        expect(() => parseEnvFile(input)).not.toThrow();

        // Result should be an array
        const result = parseEnvFile(input);
        expect(Array.isArray(result)).toBe(true);

        // Each entry should have key and value strings
        for (const entry of result) {
          expect(typeof entry.key).toBe('string');
          expect(typeof entry.value).toBe('string');
          expect(entry.key.length).toBeGreaterThan(0);
        }
      });
    }

    it('should handle all malformed inputs without crashing (bulk)', () => {
      const allInputs = malformedInputs.map((m) => m.input);
      for (const input of allInputs) {
        expect(() => parseEnvFile(input)).not.toThrow();
      }
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 7. Fuzzing: Malformed Age Ciphertext
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('Fuzzing: Malformed Age ciphertext', () => {
    const malformedCiphertexts: Array<{ name: string; input: string }> = [
      { name: 'empty string', input: '' },
      { name: 'random text', input: 'not-age-data-at-all' },
      {
        name: 'fake Age header with garbage',
        input: '-----BEGIN AGE ENCRYPTED FILE-----\ngarbage_data_here\n-----END AGE ENCRYPTED FILE-----',
      },
      { name: 'base64 gibberish', input: Buffer.alloc(10000).toString('base64') },
      { name: 'JSON string', input: JSON.stringify({ hello: 'world' }) },
      { name: 'single newline', input: '\n' },
      { name: 'null bytes', input: '\x00\x00\x00\x00' },
      { name: 'only header', input: '-----BEGIN AGE ENCRYPTED FILE-----' },
      { name: 'only footer', input: '-----END AGE ENCRYPTED FILE-----' },
      {
        name: 'valid header/footer with empty body',
        input: '-----BEGIN AGE ENCRYPTED FILE-----\n-----END AGE ENCRYPTED FILE-----',
      },
      { name: 'very long random string', input: 'X'.repeat(1_000_000) },
      { name: 'HTML content', input: '<html><body>not encrypted</body></html>' },
      { name: 'SQL injection attempt', input: "'; DROP TABLE secrets; --" },
    ];

    for (const { name, input } of malformedCiphertexts) {
      it(`should reject safely: ${name}`, async () => {
        // decrypt should throw â€” not crash
        await expect(decrypt(input, privateKey)).rejects.toThrow();
      });
    }

    it('should reject all malformed ciphertexts without crashing (bulk)', async () => {
      for (const { input } of malformedCiphertexts) {
        await expect(decrypt(input, privateKey)).rejects.toThrow();
      }
    });

    it('should reject decryptState with malformed input', async () => {
      for (const { input } of malformedCiphertexts) {
        await expect(decryptState(input, privateKey)).rejects.toThrow();
      }
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 8. Cross-cutting: End-to-end secret lifecycle
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  describe('End-to-end Secret Lifecycle', () => {
    it('should preserve data integrity through encryptâ†’tamper-detectâ†’decrypt cycle', async () => {
      const sensitiveData = {
        'project': {
          STRIPE_KEY: { value: 'sk_live_integrity_test', addedAt: '2025-01-01' },
          DB_URL: { value: 'postgres://admin:secret@host/db', addedAt: '2025-01-01' },
        },
      };

      // Encrypt
      const ciphertext = await encryptState(sensitiveData, publicKey);
      expect(ciphertext).toContain('-----BEGIN AGE ENCRYPTED FILE-----');
      expect(ciphertext).not.toContain('sk_live_integrity_test');

      // Decrypt and verify
      const decrypted = await decryptState<typeof sensitiveData>(ciphertext, privateKey);
      expect(decrypted['project']!.STRIPE_KEY.value).toBe('sk_live_integrity_test');
      expect(decrypted['project']!.DB_URL.value).toBe('postgres://admin:secret@host/db');
    });

    it('should produce different ciphertext for same plaintext (non-deterministic)', async () => {
      const data = { secret: 'same-value' };
      const ct1 = await encryptState(data, publicKey);
      const ct2 = await encryptState(data, publicKey);

      // Age encryption is non-deterministic (ephemeral key per encrypt)
      expect(ct1).not.toBe(ct2);

      // But both decrypt to the same value
      const d1 = await decryptState<typeof data>(ct1, privateKey);
      const d2 = await decryptState<typeof data>(ct2, privateKey);
      expect(d1).toEqual(d2);
    });

    it('should handle encryptâ†’writeâ†’readâ†’decrypt lifecycle on disk', async () => {
      const stateDir = path.join(globalThis.TEST_DIR, 'pentest-lifecycle');
      fs.mkdirSync(stateDir, { recursive: true });

      const data = {
        'my-app': {
          SECRET: { value: 'lifecycle-secret', addedAt: '2025-01-01T00:00:00Z' },
        },
      };

      await writeState(stateDir, data, publicKey, 'env-vars');

      // Verify on disk
      const onDisk = fs.readFileSync(path.join(stateDir, 'env-vars.age'), 'utf-8');
      expect(onDisk).toContain('-----BEGIN AGE ENCRYPTED FILE-----');
      expect(onDisk).not.toContain('lifecycle-secret');

      // Read back
      const restored = await readState(stateDir, privateKey, 'env-vars');
      expect(restored).toEqual(data);
    });

    it('should log sanitized secrets during simulated workflow', () => {
      const captured: string[] = [];
      const originalLog = console.log;
      console.log = (...args: unknown[]) => captured.push(args.map(String).join(' '));

      wrapConsole();

      // Simulate a workflow that might log secrets
      console.log('Importing env vars for project...');
      console.log('Found STRIPE_KEY=sk_live_workflow_test_key');
      console.log('Connecting to postgres://admin:workflow_secret@db.local/app');
      console.log('Using token ghp_workflow_github_token');
      console.log('Import complete!');

      unwrapConsole();
      console.log = originalLog;

      const allOutput = captured.join('\n');
      expect(allOutput).not.toContain('sk_live_workflow_test_key');
      expect(allOutput).not.toContain('workflow_secret');
      expect(allOutput).not.toContain('ghp_workflow_github_token');
      expect(allOutput).toContain('***REDACTED***');
      expect(allOutput).toContain('Importing env vars');
      expect(allOutput).toContain('Import complete!');
    });
  });
});
